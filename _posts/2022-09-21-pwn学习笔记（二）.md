---
layout: post
title: "Pwn学习笔记 (二)"
author: "1llysviel"
categories: journal
tags: [documentation]
image: ELF.png
---

# Pwn学习笔记 二

----

虚拟储存器的功能

- 它将主存看成一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据（这里存在“交换空间”以及“页面调度”等概念），通过这种方式，高效地利用主存；
- 它为每个进程提供了统一的地址空间（以虚拟地址编址），从而简化了存储器管理；
- 操作系统会为每个进程提供独立的地址空间，从而保护了每个进程的地址空间不被其他进程破坏。 
  

大端序与小端序

	小端序 LSB

- 低地址存放数据低位、高地址存放数字高位

	 大端序 MSB

- 低地址存放数据高位、高地址存放数字低位

四、CPU与进程的执行

Program Counter

- 程序计数器，或PC。也称为指令指针，或指令地址寄存器，或仅仅是指令时序（在某些计算机中）的一部分，是一个处理器寄存器，指示计算机在其指令序列中的位置。

Register 寄存器 "%rbx"

- amd64  [Acorn RISC Machine 64] [Reduced Instruction Set Computer]
- x86

总线		//用于CPU与内存沟通数据

- Address
- Data
- instruction

静态链接程序的执行过程

LLVM

	什么是LLVM
	
		LLVM项目是模块化、可重用的编译器以及工具链技术的集合。
	
			传统编译器



			LLVM架构



			不同的前端后端使用统一的中间代码LLVM Intermediate Representation (LLVM IR)
	
	LLVM IR有3种表示形式（本质是等价的）

- text:便于阅读的文本格式，类似于汇编语言，拓展名.ll， $ clang -S -emit-llvm main.m
- memory:内存格式
- bitcode:二进制格式，拓展名.bc， $ clang -c -emit-llvm main.m

			如果需要支持一种新的编程语言，那么只需要实现一个新的前端
		
			如果需要支持一种新的硬件设备，那么只需要实现一个新的后端
		
			优化阶段是一个通用的阶段，它针对的是统一的LLVM IR，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做修改
		
			相比之下，GCC的前端和后端没分得太开，前端后端耦合在了一起。所以GCC为了支持一门新的语言，或者为了支持一个新的目标平台，就变得特别困难

LLVM现在被作为实现各种静态和运行时编译语言的通用基础结构(GCC家族、Java、.NET、Python、Ruby、Scheme、Haskell、D等)



南大 南大 静态程序分析  https://www.bilibili.com/video/av91858985



	现代编译器原理：“所有的源文件分离编译，生成二进制目标文件，暂时不给每个文件中的符号确定执行时硬件地址，而是指定一个相应的逻辑偏移地址，最后再统一地再给所有编译时产生的目标文件中的符号分配实际执行时的地址。”
	
	但这会产生一个问题
	
	Q：程序是运行在内存中的，每一个函数每一个变量都会在内存中有相应的地址，在分离式编译中，每个源文件单独编译，生成的二进制目标文件中对符号(函数，变量)地址是怎么确认的？会不会有冲突，如果发生冲突是怎么解决的？
	
	A：源文件如果引用了到本文件中没有定义的函数(变量)，只要找到了这个函数(变量)的正确声明，编译对它的处理就是记录一个符号，表示这个函数(变量)本文件中无定义，但是编译过程继续，将符号处理的工作抛给链接器
	
	→ Q：那么链接器又是如何工作的？

链接器Linker 提供了三个操作：

- 空间和地址分配（Address and Storage Allocation）
  - 空间分配：将多个文件的段糅合到一起，生成一个新的总段地址的分配：段与段之间相互叠加就可以
    左一为偏移量 右一为地址（x86）
- 符号解析（Symbol Resolution）
  主要是在其他文件中找到那些声明而在其他文件中定义的符号，并建立联系。
      #test1
      void func1(void)
      {
          printf("hello world1\r\n");
      }
      #test2
      void func2(void)
      {
          printf("hello world2\r\n");
      }
      
      $ gcc -c test1.c
      $ gcc -c test2.c
      $ nm -n test1.o  
                       U puts
      0000000000000000 T func1  
      $ nm -n test2.o  
                       U puts
      0000000000000000 T func2
      上述符号表就是在编译成二进制文件时函数和变量产生的对应的符号
      第一列是地址，第二列是当前目标所在段，第三列是对象
      其中目标函数地址都是0，如同时引用这两个文件会产生地址冲突，这时就需要链接器进行重定位
- 重定位（Relocation）
  - 收集好所有目标文件之后，一个个地为这些文件中的符号分配地址，对于这些符号的重新定址就被称为重定位

[https://www.cnblogs.com/downey-blog/p/10480282.html]:

静态链接，动态链接

静态链接是指在编译阶段直接把静态库加入到可执行文件中去，这样可执行文件会比较大。

	就是将多个目标文件组合在一起形成一个可执行文件，如将a.o 和 b.o 链接在一起形成 可执行文件ab。
	
	一是空间和地址的分配；二是符号解析和重定位↑↑

而动态链接则是指链接阶段仅仅只加入一些描述信息，而程序执行时再从系统中把相应动态库加载到内存中去。

	其中分为装载时链接和运行时链接

产生原因有两个：第一，考虑内存和磁盘空间。静态链接极大地浪费内存空间。因为在静态链接的情况下，假设有两个程序共享一个模块，那么在静态链接后输出的两个可执行文件中各有一个共享模块的副本。如果同时运行这两个可执行文件，那么这个共享模块将在磁盘和内存中都有两个副本，对磁盘和内存造成极大地浪费；第二，程序的更新。一旦程序中的一个模块被修改，那么整个程序都要重新链接、发布给用户。如果这个程序相当的大，那么后果就会更加严重！

动态链接是相对于共享对象而言的。动态链接器将程序所需要的所有共享库装载到进程的地址空间，并且将程序汇总所有为决议的符号绑定到相应的动态链接库（共享库）中，并进行重定位工作对于共享模块来说，要实现共享，那么其代码对数据的访问必须是地址无关（就是代码中的地址是固定的，当然这是用的相对地址喽）的，如何做到地址无关，编译器是这么干的，每一个共享模块，都会在其代码段有一个GOT(global offset table)段，如上图所示，Got是一个指针数组，用来存储外部变量的地址，而代码相对于Got的距离是固定的，当对外部模块变量数据和函数进行访问时，就去访问变量在GOT中的位置。

共享模块对于数据的访问方式：

本模块的全局变量和函数------相对地址

外模块的全局变量和函数-------GOT段

动态链接重定位时修改GOT中的值就实现了对变量的正确访问。

五、装载和汇编

		以Linux内核装载ELF为例简述一下装载过程。当我们在Linux系统的bash下输入一个命令执行某个ELF程序时，在用户层面，bash进程会调用fork()系统调用创建一个新的进程，然后新的进程调用execve()来执行指定的ELF文件，原先的bash进程继续返回等待刚才启动时新进程结束，然后继续等待用户输入命令。这里需注意，随着一个新进程的出现，操作系统会为它创建一个独立的虚拟地址空间。

- fork()：是UNIX或类UNIX中的分叉函数，fork函数将运行着的程序分成2个（几乎）完全一样的进程，每个进程都启动一个从代码的同一位置开始执行的线程。
- execve（执行文件）在父进程中fork一个子进程，在子进程中调用exec函数启动新的程序。exec函数一共有六个，其中execve为内核级系统调用，其他（execl，execle，execlp，execv，execvp）都是调用execve的库函数
- search_binary_handler()：遍历二进制格式handler列表，寻找合适的handler。

在进入execve()系统调用之后，Linux内核就开始进行真正的装载工作。在内核中，execve()系统调用相应的入口是sys_execve()作用：参数的检查复制；调用do_execve(),流程：查找被执行的文件，读取文件的前128个字节以判断文件的格式是elf还是其它；调用search_binary_handle(),流程：通过判断文件handler确定文件的格式，并且调用相应的装载处理程序。ELF可执行文件的装载处理过程叫load_elf_binary(),它的主要步骤如下：

1. 检查ELF可执行文件格式的有效性，比如魔数、程序头表中段的数量。
2. 寻找动态链接的“.interp”段，找到动态链接器的路径，以便于后面动态链接时会用上。
3. 读取可执行文件的程序头，并且创建虚拟空间与可执行文件的映射关系。
   
   创建虚拟空间时的页映射关系函数是虚拟空间到物理内存的映射关系，而这一步所做的事虚拟空间与可执行文件的映射关系。我们知道，当程序发生缺页是，操作系统会为物理内存分配一个物理页，然后将该缺页从磁盘中读取到内存，在设置缺页的虚拟页与物理页之间的映射关系，这样程序才可以得以正常运行。但是明显的一点是，当操作系统捕获到缺页错误时，他应当知道程序当前需要的页在可执行文件中的哪一个位置。而这就是虚拟存储与可执行文件之间的映射关系。实际上，这种映射关系仅仅是保存在操作系统内部的一个数据结构。当发生缺页错误是，CPU将控制权交给操作系统，操作系统利用专门的缺页处理例程来查询这个数据结构（映射关系），然后找到所需页所在的虚拟内存区域，以及在可执行文件的偏移，然后把该页加载进物理内存，同时将该虚拟页与物理页之间建立映射关系，最后把控制权还给进程，进程从刚才缺页位置重新开始执行。
   

4.初始化ELF进程环境。
5.将系统调用的返回地址修改成ELF可执行文件的入口点，这个入口点取决于程序的链接方式，对于静态链接的ELF可执行文件，它就是ELF文件的文件头中e_entry所指的地址；对于动态链接的ELF可执行文件，程序入口点就是动态链接器。   

   当load_elf_binary()执行完毕，返回至do_execve()在返回至sys_execve()时，系统调用的返回地址已经被改写成了被装载的ELF程序的入口地址了。所以，当sys_execve()系统调用从内核态返回到用户态时，EIP寄存器直接跳转到ELF程序的入口地址。此时，ELF可执行文件装载完成。接下来就是动态链接器对程序进行动态链接了。

